<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Survival V: Mobile Smooth</title>
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@400;800&family=Creepster&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÅ‡∏ï‡∏∞‡∏ã‡πâ‡∏≥‡πÉ‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠ */
        body { margin: 0; overflow: hidden; font-family: 'Kanit', sans-serif; background: #050505; user-select: none; -webkit-user-select: none; touch-action: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI Layers */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(10, 10, 15, 0.98); color: #ddd; transition: opacity 0.5s;
        }
        .hidden { display: none !important; }

        h1 { font-family: 'Creepster', cursive; color: #d32f2f; font-size: 4rem; margin: 0; text-shadow: 0 0 20px #ff0000; letter-spacing: 5px; }
        
        .role-selector { display: flex; gap: 20px; margin: 20px; }
        .role-card {
            width: 150px; padding: 20px; background: #222; border: 2px solid #555; cursor: pointer;
            text-align: center; border-radius: 10px; transition: 0.3s;
        }
        .role-card:hover { transform: scale(1.05); }
        .role-card.selected { border-color: gold; background: #443300; box-shadow: 0 0 15px gold; }
        .role-card.hunter-role.selected { border-color: red; background: #440000; box-shadow: 0 0 15px red; }

        .char-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 20px; }
        .char-btn {
            padding: 10px; background: #333; border: 1px solid #555; color: #aaa; cursor: pointer;
        }
        .char-btn.selected { background: #eee; color: #000; font-weight: bold; }

        button.start-btn {
            background: #d32f2f; border: none; padding: 15px 50px; font-size: 2rem;
            color: white; font-family: 'Creepster'; border-radius: 5px; cursor: pointer;
            box-shadow: 0 0 20px #ff0000; margin-top: 30px; letter-spacing: 2px;
        }
        button.start-btn:hover { background: #ff6666; transform: scale(1.1); }

        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; display: none; }
        
        #minimap-container {
            position: absolute; top: 20px; left: 20px; width: 150px; height: 150px;
            background: rgba(0, 0, 0, 0.85); border: 2px solid #666; border-radius: 8px;
            overflow: hidden; box-shadow: 0 0 10px black;
        }
        .mm-dot { position: absolute; width: 10px; height: 10px; border-radius: 50%; transform: translate(-50%, -50%); transition: top 0.1s, left 0.1s; }
        #mm-player { 
            background: #00ff00; z-index: 10; border: 2px solid white; 
            display: flex; justify-content: center; align-items: center;
        }
        .mm-arrow {
            width: 0; height: 0;
            border-left: 3px solid transparent; border-right: 3px solid transparent; border-bottom: 5px solid black; transform: translateY(-2px);
        }
        .mm-hunter { background: #ff0000; z-index: 8; box-shadow: 0 0 6px red; }
        .mm-survivor { background: #00ffff; z-index: 8; border: 1px solid blue; }
        
        #health-display {
            position: absolute; top: 180px; left: 20px; font-size: 30px; color: #ff4444;
            text-shadow: 0 0 5px black;
        }

        .action-prompt {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 215, 0, 0.9); color: black; padding: 10px 20px; border-radius: 20px;
            font-weight: bold; font-size: 1.5rem; display: none; text-shadow: 0 0 5px white; box-shadow: 0 0 10px gold;
        }
        
        #blood-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%; 
            background: radial-gradient(circle, transparent 50%, rgba(150,0,0,0.8) 100%);
            pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 8;
        }

        .status-area { position: absolute; bottom: 30px; left: 20px; }
        #stamina-bar-bg { width: 250px; height: 15px; background: #222; border: 1px solid #555; margin-bottom: 10px; }
        #stamina-bar { width: 100%; height: 100%; background: #4caf50; transition: width 0.1s; }
        
        .pc-hint {
            position: absolute; bottom: 20px; right: 20px; 
            background: rgba(0,0,0,0.5); color: #aaa; padding: 10px; border-radius: 5px; font-size: 0.8rem; text-align: right;
        }
        
        #flash-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%; 
            background: white; opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 20;
        }
        
        #recover-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff4444; font-size: 2rem; font-weight: bold; text-shadow: 2px 2px 0 black;
            display: none;
        }

        /* --- MOBILE CONTROLS --- */
        #mobile-controls {
            display: none; /* Hidden by default */
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20;
        }
        
        .touch-zone { pointer-events: auto; position: absolute; }

        #joystick-area {
            bottom: 40px; left: 40px; width: 160px; height: 160px; /* ‡πÉ‡∏´‡∏ç‡πà‡∏Ç‡∏∂‡πâ‡∏ô‡∏ô‡∏¥‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢ */
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%;
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%; width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.5); border-radius: 50%; transform: translate(-50%, -50%);
        }

        #action-area {
            bottom: 40px; right: 40px;
            display: flex; flex-direction: column-reverse; align-items: flex-end; gap: 20px;
        }
        .mob-btn {
            width: 80px; height: 80px; background: rgba(0,0,0,0.5); border: 2px solid white; border-radius: 50%;
            color: white; font-size: 30px; display: flex; justify-content: center; align-items: center;
            user-select: none; transition: 0.1s;
        }
        .mob-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }
        #btn-main { width: 100px; height: 100px; font-size: 50px; background: rgba(200, 50, 50, 0.6); }
        #btn-run.active { background: rgba(0, 255, 0, 0.6); border-color: #0f0; }

        /* Show mobile controls on touch devices */
        @media (hover: none) and (pointer: coarse) {
            #mobile-controls { display: block; }
            .pc-hint { display: none; }
        }
        
        /* Look Zone (Invisible - ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏Ç‡∏ß‡∏≤) */
        #look-zone {
            position: absolute; top: 0; right: 0; width: 60%; height: 100%; pointer-events: auto;
        }
    </style>
</head>
<body>

    <div id="game-container"></div>
    <div id="blood-overlay"></div>
    <div id="flash-overlay"></div>
    <div id="recover-msg">‡πÄ‡∏ä‡πá‡∏î‡πÄ‡∏•‡∏∑‡∏≠‡∏î...</div>

    <!-- MAIN MENU -->
    <div id="menu" class="ui-layer">
        <h1>Survival V</h1>
        <div class="role-selector">
            <div class="role-card selected" onclick="selectRole('survivor', this)">
                <div style="font-size:3rem">üèÉ</div>
                <h3>‡∏ú‡∏π‡πâ‡∏£‡∏≠‡∏î‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï</h3>
                <small>‡∏´‡∏ô‡∏µ, ‡∏û‡∏±‡∏ö‡πÑ‡∏°‡πâ, ‡πÄ‡∏•‡∏∑‡∏≠‡∏î 2</small>
            </div>
            <div class="role-card hunter-role" onclick="selectRole('hunter', this)">
                <div style="font-size:3rem">üë∫</div>
                <h3>‡∏ú‡∏π‡πâ‡∏•‡πà‡∏≤</h3>
                <small>‡πÑ‡∏•‡πà‡∏•‡πà‡∏≤, ‡∏û‡∏±‡∏á‡πÑ‡∏°‡πâ</small>
            </div>
        </div>
        <div class="char-grid" id="char-options"></div>
        <button class="start-btn" onclick="startGame()">START GAME</button>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div id="minimap-container">
            <div id="mm-player" class="mm-dot"><div class="mm-arrow"></div></div>
        </div>
        <div id="health-display">‚ù§Ô∏è‚ù§Ô∏è</div> 

        <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); font-size: 3rem; color: #fff; font-weight: bold; text-shadow: 2px 2px 4px #000;">
            <span id="timer">120</span>
        </div>
        <div class="action-prompt" id="interaction-msg">SPACE</div>
        <div class="status-area">
            <div id="stamina-bar-bg"><div id="stamina-bar"></div></div>
            <div style="color:white; font-weight:bold;">[E] ‡∏™‡∏Å‡∏¥‡∏•: <span id="skill-name" style="color:#ffeb3b"></span> <span id="skill-status" style="font-size:0.8rem; color:#aaa;"></span></div>
        </div>
        <div class="pc-hint">
            [CTRL] ‡∏ã‡πà‡∏≠‡∏ô‡πÄ‡∏°‡∏≤‡∏™‡πå<br>[W A S D] ‡πÄ‡∏î‡∏¥‡∏ô<br>[SPACE] ‡∏Ç‡πâ‡∏≤‡∏°/‡∏û‡∏±‡∏ö‡πÑ‡∏°‡πâ<br>[L-Click] ‡πÇ‡∏à‡∏°‡∏ï‡∏µ
        </div>

        <!-- MOBILE CONTROLS -->
        <div id="mobile-controls">
            <!-- Joystick -->
            <div id="joystick-area" class="touch-zone">
                <div id="joystick-knob"></div>
            </div>
            <!-- Look Zone -->
            <div id="look-zone"></div>
            <!-- Buttons -->
            <div id="action-area" class="touch-zone">
                <div class="mob-btn" id="btn-main">üëä</div>
                <div style="display:flex; gap:15px;">
                    <div class="mob-btn" id="btn-skill">‚ö°</div>
                    <div class="mob-btn" id="btn-run">üèÉ</div>
                </div>
            </div>
        </div>
    </div>

    <!-- GAME OVER -->
    <div id="game-over" class="ui-layer hidden">
        <h1 id="go-title">...</h1>
        <p id="go-msg" style="font-size:1.5rem;">...</p>
        <button class="start-btn" onclick="location.reload()">MAIN MENU</button>
    </div>

    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            
            if (type === 'skill') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now+0.2);
                gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now+0.3);
                osc.start(); osc.stop(now+0.3);
            } else if (type === 'hit') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(50, now+0.2);
                gain.gain.setValueAtTime(0.5, now); gain.gain.linearRampToValueAtTime(0, now+0.2);
                osc.start(); osc.stop(now+0.2);
            } else if (type === 'heal') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(600, now+0.5);
                gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now+0.5);
                osc.start(); osc.stop(now+0.5);
            } else if (type === 'pallet_drop') {
                osc.type = 'square'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(40, now+0.1);
                gain.gain.setValueAtTime(0.5, now); gain.gain.linearRampToValueAtTime(0, now+0.2);
                osc.start(); osc.stop(now+0.2);
            } else if (type === 'break') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(80, now);
                gain.gain.setValueAtTime(0.5, now); gain.gain.linearRampToValueAtTime(0, now+0.3);
                osc.start(); osc.stop(now+0.3);
            } else if (type === 'vault') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(400, now+0.1);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now+0.1);
                osc.start(); osc.stop(now+0.1);
            }
        }

        const config = { role: 'survivor', char: 'mercenary' };
        const state = { playing: false, time: 120, stamina: 100, skillCd: 0, speedBuff: 1.0, isVaulting: false, isAttacking: false, isRecovering: false, isBreaking: false, lastTime: 0 };
        
        let scene, camera, renderer;
        let player, aiAgents = [];
        let walls = [], pallets = [], windows = [];
        let particles = [];
        let keys = {};
        let mouseLook = { x: 0, y: 0 };
        
        // Touch Input State
        const touchInput = { x: 0, y: 0, run: false };
        
        function init() {
            updateCharOptions(); 
            const container = document.getElementById('game-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222233); 
            scene.fog = new THREE.Fog(0x222233, 20, 80);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8)); 
            const moon = new THREE.DirectionalLight(0xaaccff, 0.9); 
            moon.position.set(20, 50, 20); moon.castShadow = true; scene.add(moon);
            
            // Listeners
            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', e => keys[e.code] = false);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', () => {
                // Only lock pointer if not touching controls
                if(state.playing && !document.pointerLockElement && window.innerWidth > 768) container.requestPointerLock();
                if(state.playing && config.role === 'hunter' && window.innerWidth > 768) attack();
            });

            // Initialize Mobile Controls
            initMobileControls();

            requestAnimationFrame(animate);
        }

        function initMobileControls() {
            const joyArea = document.getElementById('joystick-area');
            const joyKnob = document.getElementById('joystick-knob');
            const lookZone = document.getElementById('look-zone');
            
            // Joystick Logic
            joyArea.addEventListener('touchstart', (e) => handleJoy(e, joyArea, joyKnob));
            joyArea.addEventListener('touchmove', (e) => handleJoy(e, joyArea, joyKnob));
            joyArea.addEventListener('touchend', (e) => resetJoy(joyKnob));
            
            // Look Logic (Increased Sensitivity)
            let lastTouchX = 0;
            lookZone.addEventListener('touchstart', (e) => { lastTouchX = e.touches[0].clientX; });
            lookZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const x = e.touches[0].clientX;
                const dx = x - lastTouchX;
                lastTouchX = x;
                if(state.playing) player.rotation.y -= dx * 0.02; // Sensitivity Increased (was 0.005)
            });

            // Buttons Logic
            document.getElementById('btn-main').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                e.stopPropagation();
                if(config.role === 'hunter') attack(); 
                else tryInteract(); 
            });
            document.getElementById('btn-skill').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                e.stopPropagation();
                useSkill(); 
            });
            document.getElementById('btn-run').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                e.stopPropagation();
                touchInput.run = !touchInput.run;
                e.target.classList.toggle('active', touchInput.run);
            });
        }

        function handleJoy(e, area, knob) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = area.getBoundingClientRect();
            const cx = rect.left + rect.width/2;
            const cy = rect.top + rect.height/2;
            
            let dx = touch.clientX - cx;
            let dy = touch.clientY - cy;
            
            const maxDist = rect.width/2;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist > maxDist) {
                dx = (dx/dist) * maxDist;
                dy = (dy/dist) * maxDist;
            }
            
            knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            
            // Update state (-1 to 1)
            touchInput.x = dx / maxDist;
            touchInput.y = dy / maxDist;
        }

        function resetJoy(knob) {
            knob.style.transform = `translate(-50%, -50%)`;
            touchInput.x = 0;
            touchInput.y = 0;
        }

        function selectRole(r, el) {
            config.role = r;
            document.querySelectorAll('.role-card').forEach(e => e.classList.remove('selected'));
            el.classList.add('selected');
            updateCharOptions();
        }

        function updateCharOptions() {
            const grid = document.getElementById('char-options');
            grid.innerHTML = '';
            const survivors = [{ id: 'mercenary', name: '‡∏ó‡∏´‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏à‡πâ‡∏≤‡∏á (Dash)' }, { id: 'doctor', name: '‡∏´‡∏°‡∏≠ (Heal)' }, { id: 'thief', name: '‡πÇ‡∏à‡∏£ (Flash)' }];
            const hunters = [{ id: 'ripper', name: 'The Ripper (Speed)' }, { id: 'clown', name: 'Clown (Dash)' }];
            const list = config.role === 'survivor' ? survivors : hunters;
            
            list.forEach((c, idx) => {
                const btn = document.createElement('div');
                btn.className = `char-btn ${idx===0?'selected':''}`;
                btn.innerText = c.name;
                btn.onclick = () => {
                    config.char = c.id;
                    document.querySelectorAll('.char-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                };
                if(idx===0) config.char = c.id;
                grid.appendChild(btn);
            });
        }

        function startGame() {
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('hud').style.display = 'block';
            while(scene.children.length > 0){ scene.remove(scene.children[0]); }
            particles = [];
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const moon = new THREE.DirectionalLight(0xaaccff, 0.9);
            moon.position.set(20, 50, 20); moon.castShadow = true; scene.add(moon);

            createMap();
            spawnCharacters();
            
            state.playing = true; state.time = 120; state.stamina = 100; state.speedBuff = 1.0;
            updateHealthUI();
            
            const names = {
                'mercenary': '‡∏û‡∏∏‡πà‡∏á‡∏ï‡∏±‡∏ß (Dash)', 'doctor': '‡∏£‡∏±‡∏Å‡∏©‡∏≤ (Heal)', 'thief': '‡πÑ‡∏ü‡∏â‡∏≤‡∏¢ (Flash)',
                'ripper': '‡∏´‡∏°‡∏≠‡∏Å‡∏≠‡∏≥‡∏û‡∏£‡∏≤‡∏á (Speed)', 'clown': '‡∏û‡∏∏‡πà‡∏á‡∏ä‡∏ô (Charge)'
            };
            document.getElementById('skill-name').innerText = names[config.char] || 'Skill';
        }

        function createMap() {
            walls = []; pallets = []; windows = [];
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x444455 }));
            floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; scene.add(floor);

            const mapData = [
                "111111111111111", "100000000000001", "101110101111101", "100000100000001", "111P101W1111101",
                "100000000000001", "101111101P11101", "100000001000001", "1011W1101011101", "100000100000001",
                "11111011101P111", "100000000000001", "111111111111111"
            ];
            const unit = 6;
            const wallGeo = new THREE.BoxGeometry(unit, 6, unit);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x555566, roughness: 0.8 });

            for(let z=0; z<mapData.length; z++) {
                for(let x=0; x<mapData[z].length; x++) {
                    const char = mapData[z][x];
                    const posX = (x - 7) * unit; const posZ = (z - 6) * unit;
                    if(char === '1') {
                        const w = new THREE.Mesh(wallGeo, wallMat);
                        w.position.set(posX, 3, posZ); w.castShadow = true; w.receiveShadow = true; scene.add(w); walls.push(w);
                    } else if (char === 'P') {
                        createPallet(posX, posZ);
                        const sw = new THREE.Mesh(new THREE.BoxGeometry(unit/3, 6, unit/3), wallMat);
                        sw.position.set(posX - unit/2.5, 3, posZ); scene.add(sw); walls.push(sw);
                        const sw2 = sw.clone(); sw2.position.set(posX + unit/2.5, 3, posZ); scene.add(sw2); walls.push(sw2);
                    } else if (char === 'W') {
                        const winBase = new THREE.Mesh(new THREE.BoxGeometry(unit, 2, unit/2), wallMat);
                        winBase.position.set(posX, 1, posZ); scene.add(winBase); walls.push(winBase);
                        windows.push({position: new THREE.Vector3(posX, 1, posZ)});
                    }
                }
            }
        }

        function createPallet(x, z) {
            const geo = new THREE.BoxGeometry(1.2, 4, 3);
            const mat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 2, z);
            mesh.userData = { isPallet: true, dropped: false, broken: false };
            scene.add(mesh); pallets.push(mesh);
        }

        function spawnCharacters() {
            aiAgents = [];
            const mmContainer = document.getElementById('minimap-container');
            const dots = mmContainer.querySelectorAll('.mm-dot:not(#mm-player)');
            dots.forEach(d => d.remove());

            if(config.role === 'survivor') {
                player = createHumanoid(0x00ff00, 0.8, false);
                setSafePosition(player, 0, 30);
                
                const hunter = createHumanoid(0xff0000, 1.2, true);
                setSafePosition(hunter, 0, -30);
                Object.assign(hunter.userData, { role: 'hunter', speed: 12.5, attackCd: 0, aiActionCd: 0, recoveryTimer: 0, stuckTimer: 0, lastPos: new THREE.Vector3() });
                scene.add(hunter); aiAgents.push(hunter); createMinimapDot(hunter, 'mm-hunter');
            } else {
                player = createHumanoid(0xff0000, 1.2, true);
                setSafePosition(player, 0, -30);

                for(let i=0; i<3; i++) {
                    const s = createHumanoid(0x00ff00, 0.8, false);
                    setSafePosition(s, (Math.random()-0.5)*40, (Math.random()-0.5)*40);
                    Object.assign(s.userData, { 
                        role: 'survivor', speed: 9.5, 
                        wanderTarget: null, changeDirTimer: 0, aiActionCd: 0, stuckTimer: 0, lastPos: new THREE.Vector3()
                    });
                    scene.add(s); aiAgents.push(s); createMinimapDot(s, 'mm-survivor');
                }
            }
            scene.add(player);
            mouseLook.x = 0; mouseLook.y = 0;
        }

        function setSafePosition(agent, x, z) {
            agent.position.set(x, 0, z);
            let attempts = 0;
            while(checkCollision(agent.position, agent.userData.role==='hunter') && attempts < 200) {
                agent.position.x = (Math.random() - 0.5) * 80;
                agent.position.z = (Math.random() - 0.5) * 80;
                attempts++;
            }
            if(attempts >= 200) agent.position.set(0,0,0);
        }

        function createMinimapDot(agent, className) {
            const dot = document.createElement('div');
            dot.className = `mm-dot ${className}`;
            document.getElementById('minimap-container').appendChild(dot);
            agent.userData.mmDot = dot;
        }

        function createHumanoid(color, scale, isHunter) {
            const g = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: color, emissive: isHunter ? 0x000000 : 0x004400, emissiveIntensity: 0.5 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 0.6), mat); body.position.y = 1; g.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({color:0xffccaa})); head.position.y = 2.4; g.add(head);
            
            g.userData = { 
                hp: 2, 
                maxHp: 2, 
                invulnerable: 0,
                speedBurst: 1.0,
                isVaulting: false,
                recoveryTimer: 0
            };

            if(isHunter) {
                const light = new THREE.SpotLight(0xff0000, 5, 20, Math.PI/4, 0.5);
                light.position.set(0, 3, 0.5); light.target.position.set(0, 0, 10);
                g.add(light); g.add(light.target);
                const eye = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.15, 0.2), new THREE.MeshBasicMaterial({color:0xff0000}));
                eye.position.set(0, 2.5, 0.4); g.add(eye);
            } else {
                 const eye = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.2), new THREE.MeshBasicMaterial({color:0xffff00}));
                 eye.position.set(0, 2.5, 0.4); g.add(eye);
                 const indicator = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
                 indicator.position.y = 4.0; g.add(indicator);
            }
            g.scale.set(scale, scale, scale);
            return g;
        }

        function checkCollision(pos, isHunter) {
            const radius = isHunter ? 1.0 : 0.6; // Slightly increased radius
            const playerBox = new THREE.Box3();
            playerBox.min.set(pos.x - radius, 0, pos.z - radius);
            playerBox.max.set(pos.x + radius, 2, pos.z + radius);

            for(let w of walls) {
                const wallBox = new THREE.Box3().setFromObject(w);
                if(playerBox.intersectsBox(wallBox)) return true;
            }
            for(let p of pallets) {
                if(p.userData.broken) continue;
                if(p.userData.dropped) {
                    p.updateMatrixWorld();
                    const pBox = new THREE.Box3().setFromObject(p);
                    if(playerBox.intersectsBox(pBox)) return true;
                }
            }
            return false;
        }

        function forceUnstuck(agent) {
            const directions = [
                new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
                new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1),
                new THREE.Vector3(1,0,1), new THREE.Vector3(-1,0,1),
                new THREE.Vector3(1,0,-1), new THREE.Vector3(-1,0,-1),
            ];
            for (let d of directions) {
                const test = agent.position.clone().add(d.normalize().multiplyScalar(1.5));
                if (!checkCollision(test, agent.userData.role === 'hunter')) {
                    agent.position.copy(test); return true;
                }
            }
            setSafePosition(agent, 0, 0); return false;
        }

        // --- DAMAGE SYSTEM ---
        function takeDamage(victim) {
            if (victim.userData.invulnerable > 0) return;

            victim.userData.hp--;
            victim.userData.invulnerable = 2.0; 
            playSound('hit');
            createEffect('blood', victim.position); 

            if (victim === player) {
                document.getElementById('flash-overlay').style.backgroundColor = 'red';
                document.getElementById('flash-overlay').style.opacity = 0.5;
                setTimeout(()=>document.getElementById('flash-overlay').style.opacity=0, 300);
            }

            if (victim.userData.hp <= 0) {
                if (victim === player) {
                    gameOver(false);
                } else {
                    scene.remove(victim);
                    if(victim.userData.mmDot) victim.userData.mmDot.remove();
                    aiAgents = aiAgents.filter(a => a !== victim);
                }
            } else {
                victim.children[0].material.color.setHex(0x550000); 
                victim.userData.speedBurst = 1.8;
                setTimeout(() => victim.userData.speedBurst = 1.0, 2000);
            }
            updateHealthUI();
        }

        function updateHealthUI() {
            if (!player || !player.userData) return;
            if (config.role === 'survivor') {
                let hearts = "";
                for(let i=0; i<player.userData.hp; i++) hearts += "‚ù§Ô∏è";
                for(let i=player.userData.hp; i<2; i++) hearts += "üíî";
                document.getElementById('health-display').innerText = hearts;
                document.getElementById('health-display').style.display = 'block';
            } else {
                document.getElementById('health-display').style.display = 'none';
            }
        }

        function createEffect(type, pos) {
            if(type === 'heal') {
                const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true });
                for(let i=0; i<8; i++) {
                    const p = new THREE.Mesh(geo, mat);
                    p.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*2, Math.random(), (Math.random()-0.5)*2));
                    p.userData = { vel: new THREE.Vector3(0, 0.05, 0), life: 1.0 };
                    scene.add(p); particles.push(p);
                }
            } else if (type === 'blood') {
                const geo = new THREE.SphereGeometry(0.15);
                const mat = new THREE.MeshBasicMaterial({ color: 0xaa0000, transparent: true });
                for(let i=0; i<10; i++) {
                    const p = new THREE.Mesh(geo, mat);
                    p.position.copy(pos).add(new THREE.Vector3(0, 1.5, 0));
                    p.userData = { 
                        vel: new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.5, (Math.random()-0.5)*0.5), 
                        life: 0.8 
                    };
                    scene.add(p); particles.push(p);
                }
            } else if (type === 'dash') {
                const ghost = player.clone();
                ghost.position.copy(pos);
                ghost.rotation.copy(player.rotation);
                ghost.children.forEach(c => {
                    if(c.material) {
                        c.material = c.material.clone();
                        c.material.transparent = true;
                        c.material.opacity = 0.5;
                        c.material.color.setHex(0xaaaaaa);
                    }
                });
                for(let i=ghost.children.length-1; i>=0; i--) if(!ghost.children[i].isMesh) ghost.remove(ghost.children[i]);
                ghost.userData = { life: 0.4, type: 'ghost' };
                scene.add(ghost); particles.push(ghost);
            } else if (type === 'flash') {
                if(config.role === 'hunter') {
                    document.getElementById('flash-overlay').style.backgroundColor = 'white';
                    document.getElementById('flash-overlay').style.opacity = 0.8;
                    setTimeout(() => document.getElementById('flash-overlay').style.opacity = 0, 200);
                }
            } else if (type === 'rage') {
                const geo = new THREE.SphereGeometry(0.2);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true });
                for(let i=0; i<5; i++) {
                    const p = new THREE.Mesh(geo, mat);
                    p.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5), 0.5, (Math.random()-0.5)));
                    p.userData = { vel: new THREE.Vector3(0, 0.1, 0), life: 0.8 };
                    scene.add(p); particles.push(p);
                }
            }
        }

        function updateParticles(dt) {
            for(let i = particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.userData.life -= dt;
                
                if(p.userData.type === 'ghost') {
                    p.children.forEach(c => c.material.opacity = p.userData.life);
                } else if(p.userData.vel) {
                    p.position.add(p.userData.vel);
                    p.material.opacity = p.userData.life;
                    if(!p.userData.type) p.userData.vel.y -= 0.02; // Gravity
                }
                
                if(p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        function tryInteract() {
            if(state.isVaulting || state.isBreaking || state.isRecovering) return;
            for(let p of pallets) {
                if(p.userData.broken) continue;
                if(player.position.distanceTo(p.position) < 3.5) {
                    if(config.role === 'survivor') {
                        if(!p.userData.dropped) {
                            p.rotation.z = Math.PI / 2; p.position.y = 0.5; p.userData.dropped = true; playSound('pallet_drop'); 
                            return;
                        } else { performVault(player, p.position); return; }
                    } else { 
                         if(p.userData.dropped) {
                             state.isBreaking = true; playSound('break');
                             setTimeout(() => { scene.remove(p); p.userData.broken = true; state.isBreaking = false; }, 1000);
                             return;
                         }
                    }
                }
            }
            for(let w of windows) {
                if(player.position.distanceTo(w.position) < 3.0) { performVault(player, w.position); return; }
            }
        }

        function performVault(agent, targetPos) {
            if(agent.userData.isVaulting) return;
            agent.userData.isVaulting = true;
            if(agent === player) state.isVaulting = true;
            
            playSound('vault');
            
            const dir = new THREE.Vector3().subVectors(targetPos, agent.position).normalize();
            dir.y = 0;
            const start = agent.position.clone();
            const end = targetPos.clone().add(dir.multiplyScalar(3.0));
            let p = 0;
            const iv = setInterval(() => {
                p += 0.1;
                agent.position.lerpVectors(start, end, p);
                agent.position.y = Math.sin(p * Math.PI) * 1.5;
                if(p >= 1) { 
                    clearInterval(iv); agent.position.y = 0; 
                    agent.userData.isVaulting = false; 
                    if(agent === player) state.isVaulting = false; 
                }
            }, 30);
        }

        function attack() {
            if(state.isAttacking || state.isRecovering) return;
            state.isAttacking = true;
            const startZ = player.children[0].position.z; player.children[0].position.z += 0.5;
            // playSound('hit'); // Moved logic inside hit check for specific hits vs misses
            
            let hitSomething = false;
            const range = 4.0; const fwd = new THREE.Vector3(0,0,1).applyQuaternion(player.quaternion);
            for(let agent of aiAgents) {
                if(agent.userData.role === 'survivor') {
                    const dist = player.position.distanceTo(agent.position);
                    if(dist < range) {
                        const dir = new THREE.Vector3().subVectors(agent.position, player.position).normalize();
                        if(fwd.dot(dir) > 0.5) {
                            takeDamage(agent);
                            hitSomething = true;
                        }
                    }
                }
            }

            if(hitSomething) {
                state.isRecovering = true;
                document.getElementById('recover-msg').style.display = 'block';
                setTimeout(() => {
                    state.isRecovering = false;
                    document.getElementById('recover-msg').style.display = 'none';
                }, 2000);
            }

            setTimeout(() => { player.children[0].position.z = startZ; state.isAttacking = false; }, 800);
        }

        function onKeyDown(e) { keys[e.code] = true; if(e.code === 'Space') tryInteract(); if(e.code === 'KeyE') useSkill(); }
        function onMouseMove(e) { if(!state.playing || !document.pointerLockElement) return; player.rotation.y -= e.movementX * 0.003; }
        function onResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function useSkill() {
            if(state.skillCd > 0) return;
            state.skillCd = 12; // Base CD
            playSound('skill');
            
            if (config.char === 'mercenary' || config.char === 'clown') {
                const dashDur = 15; 
                let f = 0;
                const dashInt = setInterval(() => {
                    const fwd = new THREE.Vector3(0,0,1).applyQuaternion(player.quaternion);
                    const next = player.position.clone().add(fwd.multiplyScalar(1.2));
                    if(!checkCollision(next, config.role==='hunter')) player.position.copy(next);
                    if(f % 3 === 0) createEffect('dash', player.position);
                    f++;
                    if(f >= dashDur) clearInterval(dashInt);
                }, 20);
                
            } else if (config.char === 'doctor') {
                if(player.userData.hp < 2) {
                    player.userData.hp++;
                    player.children[0].material.color.setHex(0x00ff00);
                    updateHealthUI();
                    createEffect('heal', player.position);
                    playSound('heal');
                }
            } else if (config.char === 'thief') {
                createEffect('flash', player.position);
                aiAgents.forEach(a => {
                    if(a.userData.role === 'hunter' && player.position.distanceTo(a.position) < 15) {
                        const push = a.position.clone().sub(player.position).normalize().multiplyScalar(5);
                        a.position.add(push);
                    }
                });
            } else if (config.char === 'ripper') {
                state.speedBuff = 1.5; state.skillCd = 15;
                const rageInt = setInterval(() => createEffect('rage', player.position), 100);
                setTimeout(() => { state.speedBuff = 1.0; clearInterval(rageInt); }, 3000);
            }

            document.getElementById('skill-status').innerText = "(Cooldown)";
            setTimeout(() => document.getElementById('skill-status').innerText = "Ready!", state.skillCd * 1000);
        }

        function animate(time) {
            requestAnimationFrame(animate); renderer.render(scene, camera);
            if(!state.playing) return;
            const dt = (time - state.lastTime) / 1000 || 0.016; state.lastTime = time;

            state.time -= dt;
            document.getElementById('timer').innerText = Math.ceil(state.time);
            if(state.time <= 0 || (config.role==='hunter' && aiAgents.length===0)) {
                gameOver(config.role==='survivor');
            }

            updateParticles(dt);
            if(state.skillCd > 0) state.skillCd -= dt;
            if(player.userData.invulnerable > 0) player.userData.invulnerable -= dt;

            // Player Move Logic
            if(!state.isVaulting && !state.isBreaking && !state.isAttacking && !state.isRecovering) {
                let speed = (config.role==='hunter' ? 12 : 10) * dt * (state.speedBuff || 1.0) * (player.userData.speedBurst || 1.0);
                
                // Combine keys and touch input
                let inputX = 0;
                let inputY = 0;

                // Keyboard input
                if(keys['KeyW']) inputY += 1;
                if(keys['KeyS']) inputY -= 1;
                if(keys['KeyA']) inputX += 1; // Left is positive in our logic below (right vector negated)
                if(keys['KeyD']) inputX -= 1;

                // Touch input
                if(touchInput.y !== 0 || touchInput.x !== 0) {
                    // Touch Y < 0 is up on screen -> Forward
                    inputY += -touchInput.y;
                    // Touch X < 0 is left -> Left
                    inputX += -touchInput.x;
                }

                // Sprint check
                if((keys['ShiftLeft'] || touchInput.run) && state.stamina > 0) { 
                    speed *= 1.5; 
                    state.stamina -= 10*dt; 
                }

                if(inputX !== 0 || inputY !== 0) {
                    const fwd = new THREE.Vector3(0,0,1).applyQuaternion(player.quaternion);
                    const right = new THREE.Vector3(-1,0,0).applyQuaternion(player.quaternion);
                    const moveDir = new THREE.Vector3();
                    
                    // Forward/Back
                    if(inputY > 0) moveDir.add(fwd);
                    if(inputY < 0) moveDir.add(fwd.clone().negate());
                    
                    // Left/Right
                    if(inputX > 0) moveDir.add(right.clone().negate()); // A/Left adds -right
                    if(inputX < 0) moveDir.add(right); // D/Right adds right

                    moveDir.normalize();
                    
                    const nextPos = player.position.clone().add(moveDir.multiplyScalar(speed));
                    if(!checkCollision(nextPos, config.role==='hunter')) { player.position.copy(nextPos); }
                    else {
                        const slideX = player.position.clone().add(new THREE.Vector3(moveDir.x * speed, 0, 0));
                        if(!checkCollision(slideX, config.role==='hunter')) player.position.copy(slideX);
                        else {
                            const slideZ = player.position.clone().add(new THREE.Vector3(0, 0, moveDir.z * speed));
                            if(!checkCollision(slideZ, config.role==='hunter')) player.position.copy(slideZ);
                        }
                    }
                }
            }

            const offset = new THREE.Vector3(0, 5, -6).applyQuaternion(player.quaternion);
            camera.position.lerp(player.position.clone().add(offset), 0.2);
            camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 2, 0)));

            updateAI(dt); updateUI();
        }

        function updateAI(dt) {
            aiAgents.forEach(agent => {
                if(agent.userData.isVaulting) return; 

                // AI Hunter Recovery
                if(agent.userData.role === 'hunter' && agent.userData.recoveryTimer > 0) {
                    agent.userData.recoveryTimer -= dt;
                    return;
                }

                const speed = agent.userData.speed * dt * (agent.userData.speedBurst || 1.0);
                if(agent.userData.invulnerable > 0) agent.userData.invulnerable -= dt;
                
                const dist = agent.position.distanceTo(player.position);
                let dir = new THREE.Vector3();

                // AI Actions Cooldown
                if(agent.userData.aiActionCd > 0) agent.userData.aiActionCd -= dt;

                // Stuck Detection & Anti-Stuck
                if(agent.userData.lastPos) {
                    if (agent.position.distanceTo(agent.userData.lastPos) < 0.05 * dt * 60 && agent.userData.role === 'survivor') { // Not moving much
                        agent.userData.stuckTimer += dt;
                    } else {
                        agent.userData.stuckTimer = 0;
                    }
                }
                agent.userData.lastPos.copy(agent.position);

                if (agent.userData.stuckTimer > 0.5) {
                    forceUnstuck(agent);
                    agent.userData.changeDirTimer = 0; // Force new target
                    agent.userData.stuckTimer = 0;
                }

                // Check collision immediately
                if(checkCollision(agent.position, agent.userData.role==='hunter')) { forceUnstuck(agent); return; }

                if(agent.userData.role === 'hunter') {
                    if(agent.userData.attackCd > 0) agent.userData.attackCd -= dt;
                    
                    if(dist < 1.5) { 
                        if(agent.userData.attackCd <= 0) {
                            takeDamage(player); 
                            agent.userData.attackCd = 2.0;
                            agent.userData.recoveryTimer = 2.0; // AI Hunter Wipe Blood
                        }
                    } else if(dist < 40) { // Chasing
                        dir.subVectors(player.position, agent.position).normalize();
                        agent.lookAt(player.position);
                        
                        if(agent.userData.aiActionCd <= 0) {
                            for(let p of pallets) {
                                if(p.userData.dropped && !p.userData.broken && agent.position.distanceTo(p.position) < 2.5) {
                                    playSound('break');
                                    agent.userData.aiActionCd = 2.0; 
                                    setTimeout(() => { scene.remove(p); p.userData.broken = true; }, 1000);
                                    return; 
                                }
                            }
                            for(let w of windows) {
                                if(agent.position.distanceTo(w.position) < 2.5) {
                                    performVault(agent, w.position);
                                    agent.userData.aiActionCd = 2.0;
                                    return;
                                }
                            }
                        }
                    }
                } else {
                    // Survivor AI
                    if(dist < 25) { // Running away
                        dir.subVectors(agent.position, player.position).normalize();
                        agent.lookAt(agent.position.clone().add(dir)); agent.userData.changeDirTimer = 0; 
                        
                        if(agent.userData.aiActionCd <= 0) {
                            for(let w of windows) {
                                if(agent.position.distanceTo(w.position) < 2.5) {
                                    performVault(agent, w.position);
                                    agent.userData.aiActionCd = 2.0;
                                    return;
                                }
                            }
                        }

                    } else { // Wandering
                        agent.userData.changeDirTimer -= dt;
                        if(agent.userData.changeDirTimer <= 0) {
                            agent.userData.wanderTarget = new THREE.Vector3((Math.random()-0.5)*80, 0, (Math.random()-0.5)*80);
                            agent.userData.changeDirTimer = 3 + Math.random()*4; 
                        }
                        if(agent.userData.wanderTarget) {
                            dir.subVectors(agent.userData.wanderTarget, agent.position).normalize();
                            agent.lookAt(agent.userData.wanderTarget);
                        }
                    }
                }

                if(dir.length() > 0) {
                    const moveVec = dir.multiplyScalar(speed);
                    const nextPos = agent.position.clone().add(moveVec);
                    if(!checkCollision(nextPos, agent.userData.role==='hunter')) { agent.position.copy(nextPos); }
                    else {
                        const nextX = agent.position.clone(); nextX.x += moveVec.x; let moved = false;
                        if(!checkCollision(nextX, agent.userData.role==='hunter')) { agent.position.x += moveVec.x; moved = true; }
                        const nextZ = agent.position.clone(); nextZ.z += moveVec.z;
                        if(!checkCollision(nextZ, agent.userData.role==='hunter')) { agent.position.z += moveVec.z; moved = true; }
                        if(!moved && agent.userData.role === 'survivor') agent.userData.changeDirTimer = 0; 
                    }
                }
                
                if(agent.userData.mmDot) {
                    const mmX = (agent.position.x + 50) * 1.5; const mmZ = (agent.position.z + 50) * 1.5;
                    agent.userData.mmDot.style.left = mmX + 'px'; agent.userData.mmDot.style.top = mmZ + 'px';
                }
            });
        }

        function updateUI() {
            document.getElementById('stamina-bar').style.width = state.stamina + "%";
            if(state.stamina < 100) state.stamina += 0.05;
            
            const mmPlayer = document.getElementById('mm-player');
            const pX = (player.position.x + 50) * 1.5; const pZ = (player.position.z + 50) * 1.5;
            mmPlayer.style.left = pX + 'px'; mmPlayer.style.top = pZ + 'px';
            const rot = -player.rotation.y * (180/Math.PI); mmPlayer.style.transform = `translate(-50%, -50%) rotate(${rot}deg)`;

            let showPrompt = false; let msg = "";
            for(let p of pallets) {
                if(!p.userData.broken && player.position.distanceTo(p.position) < 3.5) {
                    showPrompt = true;
                    if(config.role === 'survivor') msg = p.userData.dropped ? "SPACE: ‡∏Ç‡πâ‡∏≤‡∏°" : "SPACE: ‡∏û‡∏±‡∏ö‡πÑ‡∏°‡πâ";
                    else msg = p.userData.dropped ? "SPACE: ‡∏û‡∏±‡∏á‡πÑ‡∏°‡πâ" : "";
                    if(msg === "") showPrompt = false;
                }
            }
            if(!showPrompt) { for(let w of windows) { if(player.position.distanceTo(w.position) < 3.0) { showPrompt = true; msg = "SPACE: ‡∏Ç‡πâ‡∏≤‡∏°"; } } }
            const promptEl = document.getElementById('interaction-msg'); promptEl.style.display = showPrompt ? 'block' : 'none'; promptEl.innerText = msg;
        }

        function gameOver(win) {
            state.playing = false;
            document.getElementById('hud').style.display = 'none'; 
            document.getElementById('game-over').classList.remove('hidden');
            document.exitPointerLock(); 
            const t = document.getElementById('go-title');
            const m = document.getElementById('go-msg');
            if(win) { t.innerText = "Escaped!"; t.style.color = "green"; m.innerText = "You survived the night."; }
            else { t.innerText = "Game Over"; t.style.color = "red"; m.innerText = "The hunter caught you."; }
        }

        window.onload = init;
    </script>
</body>
</html>
